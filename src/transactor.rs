//! read and write to lin-kv
use crate::messages::*;
use crate::node::Node;
use crate::thunk::Thunk;
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

const DB_KEY: &str = "ROOT";

pub struct Transactor {
    node: Rc<RefCell<Node>>,
}

#[derive(Debug, Clone)]
pub struct Database {
    inner: HashMap<String, Thunk>,
    node: Rc<RefCell<Node>>,
}

impl Database {
    pub fn transact(&self, txns: &[Query]) -> (Database, Vec<Query>) {
        let mut results = Vec::new();
        let mut new_db = self.clone();

        for txn in txns {
            let Query(op, key, value) = txn;
            eprintln!("op: {op}, key: {key}, value: {value:?}");
            match op.as_str() {
                "r" => {
                    let old_thunk = new_db.inner.get_mut(&key.to_string());
                    let old_values = old_thunk.map(|t| t.value());
                    results.push(Query(op.clone(), *key, QueryValue::Read(old_values)));
                }
                "append" => {
                    results.push(txn.clone());

                    let value = match value {
                        QueryValue::Append(v) => *v,
                        QueryValue::Read(_) => panic!("wrong value for 'append' operation"),
                    };

                    let thunk = new_db
                        .inner
                        .entry(key.to_string())
                        .or_insert_with(|| Thunk {
                            node: self.node.clone(),
                            id: None,
                            value: None,
                            dirty: false,
                        });
                    let mut old_values = thunk.value();
                    old_values.push(value);
                    // update thunk
                    thunk.value = Some(old_values);
                    // must change the id of the thunk to the new one 
                    // generated by the current node so that it will be saved
                    // to lin-kv. Previously, the id may be generated by another node.
                    thunk.id = None;
                    thunk.id();
                    thunk.dirty = true;
                }
                _ => {}
            }
        }
        (new_db, results)
    }

    pub fn from_json_value(node: Rc<RefCell<Node>>, json: serde_json::Value) -> Self {
        // key -> id
        let values: HashMap<String, String> = serde_json::from_value(json).unwrap();
        let inner = values
            .into_iter()
            .map(|(k, v)| {
                (
                    k,
                    Thunk {
                        node: node.clone(),
                        id: Some(v),
                        value: None,
                        dirty: false,
                    },
                )
            })
            .collect();
        Database { inner, node }
    }

    pub fn to_json_value(&self) -> serde_json::Value {
        let inner: HashMap<String, Option<String>> = self
            .inner
            .iter()
            .map(|(k, v)| (k.clone(), v.id.clone()))
            .collect();
        serde_json::to_value(&inner).unwrap()
    }

    pub fn save(&mut self) {
        self.inner.iter_mut().for_each(|(_, v)| v.save().unwrap());
    }
}

impl Transactor {
    const SVC: &'static str = "lin-kv";

    pub fn new(node: &Rc<RefCell<Node>>) -> Self {
        Self { node: node.clone() }
    }

    /// send a read request to lin-kv
    pub fn kv_read(&mut self, key: &serde_json::Value) -> serde_json::Value {
        let res = self.node.borrow_mut().sync_rpc(
            Self::SVC,
            MessageExtra::KvRead(KvReadExtra { key: key.clone() }),
        );

        match res {
            MessageExtra::KvReadOk(v) => v.value,
            MessageExtra::Error(err) => {
                if err.code == 20 {
                    Database {
                        inner: HashMap::new(),
                        node: self.node.clone(),
                    }
                    .to_json_value()
                } else {
                    panic!("wrong response for lin-kv read")
                }
            }
            _ => panic!("wrong response for lin-kv read"),
        }
    }

    /// send a CAS request to lin-kv
    pub fn kv_cas(
        &mut self,
        key: &serde_json::Value,
        from: &serde_json::Value,
        to: &serde_json::Value,
    ) -> MessageExtra {
        eprintln!("kv_cas key: {key}, from: {from}, to: {to}");
        let res = self.node.borrow_mut().sync_rpc(
            Self::SVC,
            MessageExtra::KvCas(KvCasData {
                key: key.clone(),
                from: from.clone(),
                to: to.clone(),
                create_if_not_exists: true,
            }),
        );

        res
    }

    /// perform a list of read and write operations
    pub fn transact(&mut self, txns: &[Query]) -> Result<Vec<Query>, ErrorExtra> {
        let db_key = serde_json::Value::String(DB_KEY.to_string());
        // Load the current value from lin-kv
        let current_db = Database::from_json_value(self.node.clone(), self.kv_read(&db_key));
        eprintln!("current db: {:#?}", current_db.inner);
        // Apply txn
        let (mut next_db, txns) = current_db.transact(txns);
        eprintln!("next db: {:#?}", next_db.inner);

        next_db.save();

        // Save resulting state iff it hasn't changed
        let res = self.kv_cas(
            &db_key,
            &current_db.to_json_value(),
            &next_db.to_json_value(),
        );
        match res {
            MessageExtra::KvCasOk => Ok(txns),
            // if cas fails, tell the client
            MessageExtra::Error(err) => Err(err),
            _ => panic!("wrong response for lin-kv cas"),
        }
    }
}
