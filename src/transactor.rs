//! read and write to lin-kv
use serde_json::json;

use crate::idgen::IdGen;
use crate::messages::*;
use crate::node::Node;
use crate::thunk::Thunk;
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

const DB_KEY: &str = "ROOT";

pub struct Transactor {
    node: Rc<RefCell<Node>>,
}

#[derive(Debug, Clone)]
pub struct Database {
    // Thunk will use its own id to get the value, i.e. HaspMap<String, Thunk<Vec<usize>>>,
    // from lin-kv store which should response with {"k1": "id1", "k2": "id2"}.
    // data flow:
    // root -> id(database pointer)
    // id -> value({"k1": "v1", "k2": "v2"}, should be deserialized to HashMap<String, Thunk<Vec<usize>>>)
    // v1 is an ID of inner thunk
    // v1 -> value([1,2,3])
    inner: Thunk<HashMap<String, Thunk<Vec<usize>>>>,
    node: Rc<RefCell<Node>>,
}

impl Database {
    pub fn transact(&self, txns: &[Query]) -> (Database, Vec<Query>) {
        let mut results = Vec::new();
        let mut new_db = self.clone();

        for txn in txns {
            let Query(op, key, value) = txn;
            eprintln!("op: {op}, key: {key}, value: {value:?}");
            match op.as_str() {
                "r" => {
                    // Thunk::value requires a mutable borrow
                    // inner.value() gets {"k1": "id1", "k2": "id2"}
                    let m = new_db.inner.value();
                    eprintln!("m1: {:#?}", m);
                    let mut old_thunk = m.get_mut(&key.to_string());
                    if let Some(thunk) = old_thunk.as_mut() {
                        if thunk.node.borrow().id.is_empty() {
                            thunk.node = self.node.clone();
                        }
                    }
                    eprintln!("thunk1: {:#?}", old_thunk);
                    // t.value() gets [1,2,3]
                    let old_values = old_thunk.map(|t| t.value());
                    results.push(Query(op.clone(), *key, QueryValue::Read(old_values.cloned())));
                }
                "append" => {
                    results.push(txn.clone());

                    let value = match value {
                        QueryValue::Append(v) => *v,
                        QueryValue::Read(_) => panic!("wrong value for 'append' operation"),
                    };

                    // FIXME:: we could get a default Thunk here so we have to
                    // set manually the thunk fields later
                    let m = new_db.inner.value();
                    eprintln!("m2: {:#?}", m);
                    let thunk = m.entry(key.to_string())
                        .or_insert_with(|| Thunk {
                            node: self.node.clone(),
                            id: None,
                            value: None,
                            dirty: false,
                        });
                    if thunk.node.borrow().id.is_empty() {
                        thunk.node = self.node.clone();
                    }
                    eprintln!("thunk2: {:#?}", thunk);

                    // update thunk
                    let old_values = thunk.value();
                    old_values.push(value);
                    // must change the id of the thunk to the new one
                    // generated by the current node so that it will be saved
                    // to lin-kv. Previously, the id may be generated by another node.
                    thunk.id = None;
                    let _ = thunk.id();
                    thunk.dirty = true;

                    // must change the id of the database to the new one
                    new_db.inner.id = None;
                    let _ = new_db.inner.id();
                    new_db.inner.dirty = true;
                }
                _ => {}
            }
        }
        (new_db, results)
    }

    pub fn from_json_value(node: Rc<RefCell<Node>>, json: serde_json::Value) -> Self {
        let root_id = serde_json::from_value(json);
        let inner = match root_id {
            Ok(id) => Thunk {
                node: node.clone(),
                id: Some(id),
                // this will be from json { "k1": "id1", "k2": "id2" }
                value: None,
                dirty: false,
            },
            Err(_) => Thunk {
                node: node.clone(),
                // TODO: revamp the API
                id: Some(IdGen::new(&node.borrow()).next_id()),
                value: None,
                dirty: false,
            },
        };

        Database { inner, node }
    }

    pub fn to_json_value(&self) -> serde_json::Value {
        let inner = self.inner.id.clone();
        serde_json::to_value(&inner).unwrap()
    }

    pub fn save(&mut self) {
        self.inner.value().iter_mut().for_each(|(_, v)| {
            // eprintln!("saving {} -> {:?}", v.id(), v.value());
            let _ = v.save();
        });
        let _ = self.inner.save();
    }
}

impl Transactor {
    const SVC: &'static str = "lin-kv";

    pub fn new(node: &Rc<RefCell<Node>>) -> Self {
        Self { node: node.clone() }
    }

    /// send a read request to lin-kv
    pub fn kv_read(&mut self, key: &serde_json::Value) -> serde_json::Value {
        let res = self.node.borrow_mut().sync_rpc(
            Self::SVC,
            MessageExtra::KvRead(KvReadExtra { key: key.clone() }),
        );

        match res {
            MessageExtra::KvReadOk(v) => v.value,
            MessageExtra::Error(err) => {
                if err.code == 20 {
                    serde_json::Value::Null
                } else {
                    panic!("wrong response for lin-kv read")
                }
            }
            _ => panic!("wrong response for lin-kv read"),
        }
    }

    /// send a CAS request to lin-kv
    pub fn kv_cas(
        &mut self,
        key: &serde_json::Value,
        from: &serde_json::Value,
        to: &serde_json::Value,
    ) -> MessageExtra {
        eprintln!("kv_cas key: {key}, from: {from}, to: {to}");
        let res = self.node.borrow_mut().sync_rpc(
            Self::SVC,
            MessageExtra::KvCas(KvCasData {
                key: key.clone(),
                from: from.clone(),
                to: to.clone(),
                create_if_not_exists: true,
            }),
        );

        res
    }

    /// perform a list of read and write operations
    pub fn transact(&mut self, txns: &[Query]) -> Result<Vec<Query>, ErrorExtra> {
        let db_key = json!(DB_KEY);
        // Load the current value from lin-kv
        let id1 = self.kv_read(&db_key);
        let current_db = Database::from_json_value(self.node.clone(), id1);
        eprintln!("current db: {:#?}", current_db.inner);
        // Apply txn
        let (mut next_db, txns) = current_db.transact(txns);
        eprintln!("next db: {:#?}", next_db.inner);

        // Save resulting state iff it hasn't changed
        if current_db.inner.id == next_db.inner.id {
            return Ok(txns);
        }
        
        next_db.save();
        let res = self.kv_cas(
            &db_key,
            &current_db.to_json_value(),
            &next_db.to_json_value(),
        );
        match res {
            MessageExtra::KvCasOk => Ok(txns),
            // if cas fails, tell the client
            MessageExtra::Error(err) => Err(err),
            _ => panic!("wrong response for lin-kv cas"),
        }
    }
}
